## 简介

Cortex-M3是一个32位处理器内核。

- 内部的数据路径是32位
- 寄存器是32位
- 存储器接口是32位
- ***地址线是多少位的？？？***

CM3 采用了哈佛结构，拥有独立的指令总线和数据总线，共享同一个存储器空间。比较复杂的应用可能需要**更多的存储系统功能**，为此 CM3 提供一个可选的 MPU，而且在需要 的情况下也可以使用外部的 cache。

***更多的存储系统功能？？***

## 寄存器组

|          R0           |   通用寄存器   |                                                              |
| :-------------------: | :------------: | ------------------------------------------------------------ |
|        **R1**         | **通用寄存器** |                                                              |
|        **R2**         |   通用寄存器   |                                                              |
|        **R3**         |   通用寄存器   |                                                              |
|        **R4**         |   通用寄存器   |                                                              |
|        **R5**         |   通用寄存器   |                                                              |
|        **R6**         |   通用寄存器   |                                                              |
|        **R7**         |   通用寄存器   |                                                              |
|        **R8**         |   通用寄存器   |                                                              |
|        **R9**         |   通用寄存器   |                                                              |
|        **R10**        |   通用寄存器   |                                                              |
|        **R11**        |   通用寄存器   |                                                              |
|        **R12**        |   通用寄存器   | 绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器 |
| **R13(MSP)/R13(PSP)** |  **堆栈指针**  | MSP:用于操作系统内核以及异常处理例程;<br />PSP:由用户的应用程序代码使用。<br />**堆栈指针的最低两位永远是 0，这意味着堆栈总是 4 字节对齐的。** |
|        **R14**        | 连接寄存器(LR) | 当调用一个子程序时，由 R14 存储返回地址，无需存于堆栈中，减少内存访问次数 |
|        **R15**        | 程序计数器(PC) | 很多高级技巧就在这里                                         |

## 操作模式和特权级

模式：handler mode/ thread mode

分级：特权级和用户级

一旦进入用 户级，再想回来就得走“法律程序”了——用户级的程序不能简简单单地试图改写 CONTROL 寄存器 就回到特权级，它必须先“申诉”：执行一条系统调用指令(SVC)。这会触发 SVC 异常，然后由异常 服务例程（通常是操作系统的一部分）接管，如果批准了进入，则异常服务例程修改 CONTROL 寄存 器，才能在用户级的线程模式下重新进入特权级。

CONTROL寄存器、SVC异常、异常服务例程

![操作模式转换图](C:\Users\RSheng\Documents\Embedded-development\The Defi nitive Guide to the\操作模式转换图.PNG)

## 内建的嵌套向量中断控制器--NVIC

- 可嵌套中断支持 ——> 优先级对比，xPSR的专用字段
- 向量中断支持 ——> 自动定位向量表，根据中断号找到ISR的入口地址，跳过去执行。
- 动态优先级调整支持 ——> ***可重入风险？？？***
- 中断延迟大大缩短
- 中断可屏蔽 ——> 让time‐critical的任务能在deadline到来前完成，而不被干扰

## 存储器映射

不像其它的 ARM 架构，它们的存储器映射由半导体厂家说了算，Cortex‐M3 预先 定义好了“粗线条的”存储器映射。不用每学一种不同的单片机就要熟悉一种新的存储器映射。

![存储器映射](C:\Users\RSheng\Documents\Embedded-development\The Defi nitive Guide to the\存储器映射.PNG)

## 总线接口

- 指令存储区总线（两条）
- 系统总线 
- 私有外设总线

## 存储器保护单元--MPU

配上它之后，就可以对特权级访问和用户级访问分 别施加不同的访问限制。它可以把某些内存 **region** 设置成只读，从而避免了那里的内容意外被 更改；还可以在多任务系统中把不同任务之间的数据区隔离。使嵌入式系统变得更加 健壮，更加可靠

## 指令系统

Cortex‐M3 内核干脆都不支持 ARM 指令，中断也在 Thumb 态下处 理（以前的 ARM 总是在 ARM 状态下处理所有的中断和异常）。

先进：

- 消灭了状态切换的额外开销，节省了both执行时间和指令空间（因为thumb 状态下的指令功能只是 ARM 下的一个子集，结果可能需要更多条的指令去完成 相同的工作）
- 不再需要把源代码文件分成ARM编译和Thumb编译，软件开发的管理大大减小。
- 无需再反复地求证和测试：究竟该在何时何地切换到何种状态下，程序才最有效率，软件开发难度减小。

**CM3 并不支持所有的 Thumb‐2 指令。**

取指都按 32 位处理。同一周期最多可以取出两条指令，留下了更多的带宽给数据传输。

## 中断和异常

CM3 的所有中断机制都由 NVIC 实现。

除了支持 240 条外部中断输入外，还支持 16‐4‐1=11 个内 部异常源，可以实现 fault 管理机制。

**虽然 CM3 是支持 240 个外中断的，但具体使用了多少个是由芯片生产商决定。**

Cortex‐M3 在进入异常服务例程时，自动压栈了 R0‐R3, R12, LR, PSR 和 PC，并且在返回时自 动弹出它们

## 调试支持

内核本身 不再含有 JTAG 接口。取而代之的，是 CPU 提供称为“调试访问接口(DAP)”的总线接口。（通过这个 总线接口，可以访问芯片的寄存器，也可以访问系统存储器，甚至是在内核运行的时候访问！）——>功能：

- 停机
- 单步执行
- 指令断点
- 数据观察点
- 寄存器和存储器访问
- 性能速写（profiling）
- 各种跟踪机制

总线接口的使用：由一个调试端口（DP）设备完成。

- 一SWJ-DP:既支持传统的JTAG调试，也支持新的串行线调试协议；
- 一SWJ-DP:去掉了JTAG的支持；
- 一使用ARM Coresignt产品家族的JTAG-DP模块。

此外，CM3 还能挂载一个所谓的“嵌入式跟踪宏单元（ETM）”。ETM 可以不断地发出跟踪信息， 这些信息通过一个被称为“跟踪端口接口单元（TPIU）”的模块而送到内核的外部，再在芯片外面使 用一个“跟踪信息分析仪”，就可以把 TIPU 输出的“已执行指令信息”捕捉到，并且送给调试主机 ——也就是 PC。

## 小节

## 问题

ST如何根据存储器映射设计自己的芯片，外设？？

如何根据总线接口和指令系统编写代码？？

ST如何设置自己的调试端口？？

MPU如何提宫更多的存储系统功能？？

